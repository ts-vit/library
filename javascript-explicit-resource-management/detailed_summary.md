# Детальная выжимка: Явное управление ресурсами в JS (2026)

Технический разбор новой возможности ECMAScript — оператора `using`. Это самое значимое изменение в управлении памятью и ресурсами со времен введения Promise.

---

### Глава 1. Проблема `try...finally`
*   **Контекст:** Раньше для закрытия файлов или баз данных мы всегда использовали блоки `try-finally`. Это раздувало код и приводило к ошибкам ("забыли закрыть соединение").
*   **Решение:** Оператор `using` делает очистку декларативной. Вы объявляете ресурс, а язык сам гарантирует его закрытие.

### Глава 2. Операторы `using` и `await using`
*   **Синхронный `using`:** Для ресурсов, которые закрываются мгновенно (например, мьютексы в памяти).
*   **Асинхронный `await using`:** Для ресурсов, требующих сетевого или дискового ожидания при закрытии (базы данных, сокеты, файловые дескрипторы).

### Глава 3. Протоколы Disposable
*   **Symbol.dispose:** Метод, который вызывается автоматически для синхронных ресурсов.
*   **Symbol.asyncDispose:** Метод для асинхронной очистки.
*   **Реализация:** Как сделать свой класс "disposable" (пригодным для использования с `using`).

### Глава 4. Жизненный цикл и Стек
*   **LIFO (Last-In, First-Out):** Если в блоке создано три ресурса, они будут закрыты в порядке, обратном их созданию. Это критично, когда один ресурс зависит от другого (например, транзакция зависит от соединения).
*   **Область видимости:** Ресурс уничтожается ровно в тот момент, когда выполнение кода выходит за закрывающую фигурную скобку `{}` блока.

### Глава 5. Контейнеры DisposableStack
*   **Гибкое управление:** Иногда ресурс нужно передать между функциями. Для этого используется `DisposableStack` — переносимый набор ресурсов, который можно закрыть одной командой `stack.dispose()`.

---
**Связь с проектом Toshik:** В `toshik-babe` мы работаем с файловой системой и API-клиентами. Переход на `await using` позволит нам сделать код более компактным и избавиться от потенциальных утечек памяти в долгоиграющих сессиях.
