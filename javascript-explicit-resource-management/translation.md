# Полный перевод: Явное управление ресурсами в JavaScript

Оригинал: [Explicit resource management in JavaScript](https://allthingssmitty.com/2026/02/02/explicit-resource-management-in-javascript/)
Автор: Matt Smith (2 февраля 2026 г.)

Когда вы пишете код на JavaScript, который открывает что-либо (файл, поток, блокировку, соединение с базой данных), это также означает, что вы должны помнить о необходимости очистки. И если быть честными, эта очистка происходит далеко не всегда. Я знаю, что сам упускал это не раз.

JavaScript всегда делал это нашей проблемой. Мы использовали `try / finally`, говорили себе, что будем осторожны, и надеялись, что не упустили пограничный случай. Обычно это работает, но это создает лишний шум в коде и в этом легко допустить тонкую ошибку. Кроме того, такой подход плохо масштабируется, когда вам приходится жонглировать более чем одним ресурсом.

Наконец-то ситуация начинает меняться. Явное управление ресурсами (Explicit resource management) дает JavaScript первоклассный способ на уровне языка сказать: «Эта штука требует очистки, и рантайм гарантирует, что она произойдет».

Не как соглашение или паттерн, а как часть самого языка.

## Мы плохи в очистке (и язык в этом не помогал)

Этот паттерн должен выглядеть знакомо:

```javascript
const file = await openFile("data.txt");

try {
 // делаем что-то с файлом
} finally {
 await file.close();
}
```

Это нормально, но также это:
- Многословно
- Повторяемо
- Легко ошибиться по мере роста сложности, особенно при рефакторинге

Теперь добавьте еще один ресурс:

```javascript
const file = await openFile("data.txt");
const lock = await acquireLock();

try {
 // работаем с файлом и блокировкой
} finally {
 await lock.release();
 await file.close();
}
```

Теперь порядок имеет значение. Пути обработки ошибок имеют значение. Вы можете продумать всё это, но ментальная нагрузка продолжает расти. А там, где есть нагрузка, обычно следуют баги.

Другие языки решили это годы назад. JavaScript (медленно) догоняет.

## using: очистка, ставшая обязанностью рантайма

На высоком уровне, `using` объявляет ресурс, который будет автоматически очищен, когда он выйдет из области видимости.

Концептуально:

```javascript
using file = await openFile("data.txt");

// работаем с файлом

// файл автоматически закрывается в конце этой области видимости
```

Никаких `try`. Никаких `finally`. Никаких вопросов «не забыл ли я закрыть это?».

Ключевой сдвиг в том, что очистка привязана к времени жизни, а не к потоку управления.

## Как на самом деле работает очистка

Ресурсы подключаются к этой системе, реализуя хорошо известный символ:
- `Symbol.dispose` для синхронной очистки
- `Symbol.asyncDispose` для асинхронной очистки

Например:

```javascript
class FileHandle {
 async write(data) {
 /* ... */
 }

 async [Symbol.asyncDispose]() {
 await this.close();
 }
}
```

Как только у значения появляется один из этих методов, его можно использовать с `using`.

И что важно, `using` не закрывает файлы магическим образом, он просто стандартизирует очистку вместо того, чтобы каждая библиотека изобретала свой собственный способ.

## Когда вам нужен await using

Если очистка является асинхронной, вы обычно используете `await using`:

```javascript
await using file = await openFile("data.txt");

// асинхронная работа с файлом
```

Когда область видимости закончится, JavaScript дождется завершения очистки (`disposal`), прежде чем продолжить.

Синхронные ресурсы (блокировки, структуры в памяти) могут использовать обычный `using`. Сначала это может показаться странным, но это соответствует тому, как JavaScript уже проводит грань между синхронным и асинхронным кодом в других местах. Важно то, что очистка происходит при выходе из области видимости.

## Стек ресурсов без головной боли

Вот где всё действительно улучшается.

Вместо:

```javascript
const file = await openFile("data.txt");
const lock = await acquireLock();

try {
 // работа
} finally {
 await lock.release();
 await file.close();
}
```

Вы пишете:

```javascript
await using file = await openFile("data.txt");
using lock = await acquireLock();

// работа
```

Очистка происходит автоматически, в обратном порядке, как в стеке:
1. Освобождается `lock`
2. Закрывается `file`

Никакого лишнего синтаксиса. Ошибки не прерывают процесс очистки, и она происходит в строго определенном порядке.

## Область видимости — это главное

Объявление `using` привязано к области видимости так же, как `const` или `let`:

```javascript
{
 await using file = await openFile("data.txt");
 // файл валиден здесь
}

// файл очищен здесь
```

Это подталкивает вас к созданию более узких областей видимости и делает время жизни ресурсов явным — то, что JavaScript исторически плохо умел выражать. Как только вы начинаете видеть время жизни прямо в коде, его становится трудно «развидеть».

## Когда using недостаточно

Не каждый ресурс аккуратно вписывается в блок кода. Иногда получение ресурса происходит по условию, или вы рефакторите старый код и не хотите вводить новые области видимости повсюду.

Здесь на помощь приходят `DisposableStack` и `AsyncDisposableStack`:

```javascript
const stack = new AsyncDisposableStack();

const file = stack.use(await openFile("data.txt"));
const lock = stack.use(await acquireLock());

// работаем с файлом и блокировкой

await stack.disposeAsync();
```

Вы получаете ту же безопасность, что и с `using`, но с большей гибкостью. Если `using` — это чистый декларативный случай, то стеки — это «запасной выход».

## Это фича не только для бэкенда

На первый взгляд может показаться, что это забота серверной части, но это применимо и во фронтенде, и в платформенном коде:
- Web Streams
- navigator.locks
- Обсерверы и подписки
- Транзакции IndexedDB

Любой, кто когда-либо писал `subscribe()` / `unsubscribe()` или `open()` / `close()`, должен как минимум задуматься об этом.

Это вопрос не только корректности. Речь идет о том, чтобы сделать время жизни видимым в коде, а не прятать его в соглашениях и комментариях.

## В чем подвох?

На начало 2026 года Chrome 123+ и Firefox 119+ поддерживают все эти функции. Node.js 20.9+ тоже. Поддержка в Safari всё еще ожидается, но она уже на горизонте.

На данный момент это то, с чем стоит экспериментировать и, возможно, начать проектировать API вокруг этого, особенно если вы поддерживаете библиотеки или абстракции платформенного уровня. Даже если вы не начнете использовать `using` завтра, модель, которую он вводит, заслуживает внимания.

## Лучший стандарт для очистки

Явное управление ресурсами не заменяет `try / finally`. Вы всё равно будете использовать его, когда вам нужен тонкий контроль.

Но что оно дает, так это лучший стандарт «по умолчанию»: меньше шаблонного кода, меньше утечек, более четкие намерения и код, который просто лучше читается. По мере того как JavaScript берет на себя всё больше системных обязанностей, подобные функции кажутся уже не просто приятным дополнением, а жизненной необходимостью.
